#!/usr/bin/env bash
# Generated by fx-testsh 
# === 01_header.sh ===
#!/usr/bin/env bash
# fx-testsh :: Legendary test runner scaffold
# Status: scaffold

# =============================================================================
# portable
# =============================================================================
set -euo pipefail
IFS=$'\n\t'

# === 05_plan.sh ===
# =============================================================================
# function plan
# =============================================================================
# main
#   options
#   dispatch
# options
# dispatch
# do_help
# do_status
# do_lint
# do_run
#   dispatch_run
# do_docs
#   dispatch_docs
# do_list
# do_version
# do_logo
# _bootstrap_paths
# _ensure_environment
# _resolve_boxy
# _emit_boxy
# _boxy_fallback
# __stderr
# __todo

# === 10_constants.sh ===
# =============================================================================
# readonly
# =============================================================================
readonly TESTSH_APP_NAME="testsh"
readonly TESTSH_APP_VERSION="0.1.0-dev"
readonly TESTSH_DEFAULT_COMMAND="status"

# =============================================================================
# config
# =============================================================================
# shellcheck disable=SC2034 # future use during scaffold hydration
declare -A TESTSH_FLAGS=(
    [help]=false
    [version]=false
    [verbose]=false
    [strict]=true
    [quick]=true
    [comprehensive]=false
    [override]=false
    [violations]=false
    [skip_enforcement]=false
)

declare -a TESTSH_ARGS=()

declare TESTSH_PROJECT_ROOT="${TESTSH_PROJECT_ROOT:-}"
declare TESTSH_TEST_ROOT="${TESTSH_TEST_ROOT:-}"
declare TESTSH_SRC_ROOT="${TESTSH_SRC_ROOT:-}"
declare TESTSH_DOC_ROOT="${TESTSH_DOC_ROOT:-}"
declare TESTSH_PROFILE="${TESTSH_PROFILE:-}"

declare TESTSH_BOXY_BIN="${TESTSH_BOXY_BIN:-}"
declare TESTSH_TIMEOUT_BIN="${TESTSH_TIMEOUT_BIN:-}"

declare -A TESTSH_TEST_MAP=(
    [sanity]="sanity"
    [smoke]="smoke"
    [unit]="unit"
    [integration]="integration"
    [e2e]="e2e"
    [uat]="uat"
    [chaos]="chaos"
    [bench]="bench"
)

declare -A TESTSH_DOC_OVERRIDE=()

# === 20_bootstrap.sh ===
# =============================================================================
# bootstrap
# =============================================================================
_bootstrap_paths() {
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    local root
    root="$(cd "$script_dir/.." && pwd)"
    TESTSH_PROJECT_ROOT="${TESTSH_PROJECT_ROOT:-$root}"
    TESTSH_TEST_ROOT="${TESTSH_TEST_ROOT:-$TESTSH_PROJECT_ROOT/tests}"
    TESTSH_SRC_ROOT="${TESTSH_SRC_ROOT:-$TESTSH_PROJECT_ROOT/src}"
    TESTSH_DOC_ROOT="${TESTSH_DOC_ROOT:-$TESTSH_PROJECT_ROOT/docs}"
    _resolve_boxy
    _resolve_timeout
    _docs_seed_default
}

_ensure_environment() {
    [[ -d "$TESTSH_TEST_ROOT" ]] || __stderr "Missing test directory: $TESTSH_TEST_ROOT"
}

_resolve_boxy() {
    local candidate=""

    if command -v boxy >/dev/null 2>&1; then
        candidate="$(command -v boxy)"
    elif [[ -f "$TESTSH_PROJECT_ROOT/target/release/boxy" ]]; then
        candidate="$TESTSH_PROJECT_ROOT/target/release/boxy"
    elif [[ -f "$TESTSH_PROJECT_ROOT/../boxy/target/release/boxy" ]]; then
        candidate="$TESTSH_PROJECT_ROOT/../boxy/target/release/boxy"
    else
        candidate=""
    fi

    TESTSH_BOXY_BIN="$candidate"
}

_resolve_timeout() {
    local bin=""

    if command -v timeout >/dev/null 2>&1; then
        bin="timeout"
    elif command -v gtimeout >/dev/null 2>&1; then
        bin="gtimeout"
    fi

    TESTSH_TIMEOUT_BIN="$bin"
}

# === 30_boxy.sh ===
_emit_boxy() {
    local content="$1"
    local theme="${2:-info}"
    local title="${3:-$TESTSH_APP_NAME}"
    local width="${4:-max}"

    if [[ -n "$TESTSH_BOXY_BIN" ]]; then
        local args=()
        [[ -n "$theme" ]] && args+=(--theme "$theme")
        [[ -n "$title" ]] && args+=(--title "$title")
        [[ -n "$width" ]] && args+=(--width "$width")

        local boxy_status=0
        set +e
        printf '%b\n' "$content" | "$TESTSH_BOXY_BIN" "${args[@]}"
        boxy_status=$?
        set -e
        [[ $boxy_status -ne 0 ]] && _boxy_fallback "$content" "$title" "$theme"
    else
        _boxy_fallback "$content" "$title" "$theme"
    fi

    printf '\n'
}

_boxy_fallback() {
    local content="$1"
    local title="${2-}"
    local theme="${3-}"

    {
        [[ -n "$title" ]] && printf '[boxy:%s] %s\n' "${theme:-plain}" "$title"
        printf '%b\n' "$content"
    } >&2
}

_emit_override_warning() {
    local warning_text="‚ö†Ô∏è  OVERRIDE MODE ACTIVE ‚ö†Ô∏è\n\nTests are being run despite organization violations.\nThis should only be used for emergency situations.\n\nRecommended actions:\n‚Ä¢ Fix test naming patterns: <category>_<module>.rs\n‚Ä¢ Create missing sanity tests\n‚Ä¢ Move tests to proper directories\n‚Ä¢ Run './bin/test.sh lint' to see violations\n\nUse './bin/test.sh run <test>' for standard enforcement."

    _emit_boxy "$warning_text" "warning" "‚ö†Ô∏è  Test Organization Override"
}

# === 40_execution.sh ===
__cargo() {
    local secs="${RSB_TEST_TIMEOUT:-600}"
    if [[ -n "$TESTSH_TIMEOUT_BIN" ]]; then
        "$TESTSH_TIMEOUT_BIN" "${secs}s" cargo "$@" 
    else
        cargo "$@"
    fi
}

_run_header() {
    local label="$1"
    local profile="${TESTSH_PROFILE:-default}"

    local mode="quick"
    [[ "${TESTSH_FLAGS[comprehensive]}" == "true" ]] && mode="comprehensive"

    local strict_state="on"
    [[ "${TESTSH_FLAGS[strict]}" == "false" ]] && strict_state="off"

    local override_state="disabled"
    [[ "${TESTSH_FLAGS[override]}" == "true" ]] && override_state="enabled"

    local theme="success"
    [[ "${TESTSH_FLAGS[override]}" == "true" ]] && theme="warning"

    local content
    printf -v content 'üöÄ Running test lane\n\nLane    : %s\nProfile : %s\nMode    : %s\nStrict  : %s\nOverride: %s' \
        "$label" "$profile" "$mode" "$strict_state" "$override_state"

    _emit_boxy "$content" "$theme" "üß™ fx-testsh"
}

_with_env() {
    local -a assignments=()
    while [[ $# -gt 0 && "$1" != "--" ]]; do
        assignments+=("$1")
        shift
    done

    if [[ $# -eq 0 ]]; then
        __stderr "‚ùå _with_env requires '--' delimiter"
        return 1
    fi

    shift

    declare -A __previous=()
    local assignment key value
    for assignment in "${assignments[@]}"; do
        key="${assignment%%=*}"
        value="${assignment#*=}"
        __previous["$key"]="${!key-__unset__}"
        export "$key"="$value"
    done

    "$@"
    local status=$?

    for key in "${!__previous[@]}"; do
        if [[ "${__previous[$key]}" == "__unset__" ]]; then
            unset "$key"
        else
            local restored="${__previous[$key]}"
            printf -v "$key" '%s' "$restored"
            export "$key"
        fi
    done

    return $status
}

_cargo_lane() {
    local lane="$1"
    local capture_mode="${2:-auto}"
    shift 2

    local -a args=("$@")
    local arg
    local has_nocapture=false
    for arg in "${args[@]}"; do
        if [[ "$arg" == "--nocapture" ]]; then
            has_nocapture=true
            break
        fi
    done

    if [[ "$capture_mode" == "force" ]]; then
        if [[ "$has_nocapture" == false ]]; then
            args+=(-- --nocapture)
        fi
    elif [[ "${TESTSH_FLAGS[verbose]}" == "true" && "$has_nocapture" == false ]]; then
        args+=(-- --nocapture)
    fi

    _run_header "$lane"

    (
        cd "$TESTSH_PROJECT_ROOT" || return 1
        __cargo "${args[@]}"
    )
}

_run_exec() {
    local lane="$1"
    local base="${2-}"
    local path_rs="$TESTSH_TEST_ROOT/$base.rs"
    local path_sh="$TESTSH_TEST_ROOT/$base.sh"
    local path_generic="$TESTSH_TEST_ROOT/$base"

    if [[ -f "$path_rs" ]]; then
        ( cd "$TESTSH_PROJECT_ROOT" && __cargo test --test "$base" -- --nocapture )
        return $?
    fi

    if [[ -f "$path_sh" ]]; then
        ( cd "$TESTSH_PROJECT_ROOT" && bash "$path_sh" )
        return $?
    fi

    if [[ -f "$path_generic" && -x "$path_generic" ]]; then
        ( cd "$TESTSH_PROJECT_ROOT" && "$path_generic" )
        return $?
    fi

    __stderr "‚ùå Unable to locate lane target for '$lane'"
    __stderr "   Checked: ${path_rs#$TESTSH_PROJECT_ROOT/}, ${path_sh#$TESTSH_PROJECT_ROOT/}"
    return 1
}

_run_env() {
    export TESTSH_RUN_VERBOSE="${TESTSH_FLAGS[verbose]}"
    export TESTSH_RUN_STRICT="${TESTSH_FLAGS[strict]}"
    export TESTSH_RUN_QUICK="${TESTSH_FLAGS[quick]}"
    export TESTSH_RUN_COMPREHENSIVE="${TESTSH_FLAGS[comprehensive]}"
    export TESTSH_RUN_OVERRIDE="${TESTSH_FLAGS[override]}"
    export TESTSH_RUN_PROFILE="${TESTSH_PROFILE:-default}"

    export RSB_TEST_MODE="true"
    export RSB_VERBOSE="${TESTSH_FLAGS[verbose]}"
    export RSB_QUICK_MODE="${TESTSH_FLAGS[quick]}"
    export RSB_COMPREHENSIVE="${TESTSH_FLAGS[comprehensive]}"
}

# === 50_lanes.sh ===
_run_module_generic() {
    local lane="$1"
    local mod="${2-}"
    local base="${3-}"
    local mode="${4:-full}"
    local label="${lane}:${mod}"

    local wrapper_rs="$TESTSH_TEST_ROOT/${lane}_${mod}.rs"
    if [[ -f "$wrapper_rs" ]]; then
        _cargo_lane "$label" force test --test "${lane}_${mod}"
        return $?
    fi

    local wrapper_sh="$TESTSH_TEST_ROOT/${lane}_${mod}.sh"
    if [[ -f "$wrapper_sh" ]]; then
        _run_header "$label"
        ( cd "$TESTSH_PROJECT_ROOT" || return 1; bash "$wrapper_sh" )
        return $?
    fi

    local wrapper_exe="$TESTSH_TEST_ROOT/${lane}_${mod}"
    if [[ -f "$wrapper_exe" && -x "$wrapper_exe" ]]; then
        _run_header "$label"
        ( cd "$TESTSH_PROJECT_ROOT" || return 1; "$wrapper_exe" )
        return $?
    fi

    local sub_sh="$TESTSH_TEST_ROOT/$lane/$mod.sh"
    if [[ -f "$sub_sh" ]]; then
        _run_header "$label"
        ( cd "$TESTSH_PROJECT_ROOT" || return 1; bash "$sub_sh" )
        return $?
    fi

    local sub_exe="$TESTSH_TEST_ROOT/$lane/$mod"
    if [[ -f "$sub_exe" && -x "$sub_exe" ]]; then
        _run_header "$label"
        ( cd "$TESTSH_PROJECT_ROOT" || return 1; "$sub_exe" )
        return $?
    fi

    if [[ "$mode" == "no-aggregator" ]]; then
        return 1
    fi

    local filter="${lane}_${mod}"
    local -a aggregators=()
    aggregators+=("$lane")
    if [[ -n "$base" && "$base" != "$lane" ]]; then
        aggregators+=("$base")
    fi

    local agg
    for agg in "${aggregators[@]}"; do
        [[ -n "$agg" ]] || continue
        [[ "$agg" == */* ]] && continue
        local agg_path="$TESTSH_TEST_ROOT/$agg.rs"
        [[ -f "$agg_path" ]] || continue

        _cargo_lane "$label" force test --test "$agg" "$filter"
        return $?
    done

    return 1
}

_run_module_rsb() {
    local lane="$1"
    local mod="${2-}"
    local base="${3-}"
    local label="${lane}:${mod}"
    local filter="${lane}_${mod}"

    case "$lane" in
        sanity)
            local -a candidates=(sanity)
            if [[ -n "$base" && "$base" != "sanity" ]]; then
                candidates+=("$base")
            fi

            local agg
            for agg in "${candidates[@]}"; do
                [[ -n "$agg" ]] || continue
                [[ "$agg" == */* ]] && continue
                local agg_path="$TESTSH_TEST_ROOT/$agg.rs"
                [[ -f "$agg_path" ]] || continue

                _cargo_lane "$label" force test --test "$agg" "$filter"
                return $?
            done
            ;;
        uat)
            local -a uat_candidates=(uat)
            if [[ -n "$base" && "$base" != "uat" ]]; then
                uat_candidates+=("$base")
            fi

            local agg
            for agg in "${uat_candidates[@]}"; do
                [[ -n "$agg" ]] || continue
                [[ "$agg" == */* ]] && continue
                local agg_path="$TESTSH_TEST_ROOT/$agg.rs"
                [[ -f "$agg_path" ]] || continue

                _with_env \
                    "RSB_COLORS=simple,status,named" \
                    "RSB_COLOR=always" \
                    -- _cargo_lane "$label" force test --features visuals --test "$agg" "$filter"
                return $?
            done
            ;;
    esac

    return 1
}

_run_module() {
    local lane="$1"
    local mod="${2-}"
    local base="${3-}"

    if [[ -z "$mod" ]]; then
        __stderr "‚ùå Module name required for lane '$lane'"
        return 1
    fi

    if [[ "${TESTSH_PROFILE}" == "rsb" ]]; then
        if _run_module_generic "$lane" "$mod" "$base" "no-aggregator"; then
            return 0
        fi

        if _run_module_rsb "$lane" "$mod" "$base"; then
            return 0
        fi
    fi

    if _run_module_generic "$lane" "$mod" "$base"; then
        return 0
    fi

    __stderr "‚ùå Module filtering not supported: lane '$lane', module '$mod'"
    return 1
}

_run_lane_rsb() {
    local lane="$1"
    local base="${2-}"

    case "$lane" in
        sanity)
            _cargo_lane "$lane" auto test --test "$base"
            return $?
            ;;
        smoke)
            _cargo_lane "$lane" auto test --test "$base"
            return $?
            ;;
        all)
            _run_header "$lane"
            local -a all_lanes=(
                sanity
                global
                param
                stdopts
                colors
                colors-runtime
                uat-colors
                uat-colors-macros
                uat-glyphs
                uat-visual
                uat-prompts
            )
            local sub status=0
            for sub in "${all_lanes[@]}"; do
                if ! _run_lane "$sub"; then
                    status=$?
                    break
                fi
            done
            return $status
            ;;
        param)
            _cargo_lane "$lane" auto test --test "$base"
            return $?
            ;;
        "param-helpers")
            _cargo_lane "$lane" auto test --test "param_helpers"
            return $?
            ;;
        "param-uat")
            _cargo_lane "$lane" force test --features visuals --test "uat_main"
            return $?
            ;;
        stdopts)
            _cargo_lane "$lane" auto test --features stdopts --test "$base"
            return $?
            ;;
        colors)
            _with_env \
                "RSB_COLORS=simple,status,named" \
                -- \
                _cargo_lane "$lane" auto test --features visuals --test "$base"
            return $?
            ;;
        "colors-runtime")
            _with_env \
                "RSB_COLORS=simple,status,named" \
                "RSB_COLOR=always" \
                -- \
                _cargo_lane "$lane" auto test --features visuals --test "$base"
            return $?
            ;;
        "uat-colors")
            _with_env \
                "RSB_COLORS=simple,status,named" \
                "RSB_COLOR=always" \
                -- \
                _cargo_lane "$lane" force test --features visuals --test "uat_main"
            return $?
            ;;
        "uat-colors-macros")
            _with_env \
                "RSB_COLORS=simple,status,named" \
                "RSB_COLOR=always" \
                -- \
                _cargo_lane "$lane" force test --features visuals --test "uat_main"
            return $?
            ;;
        "uat-stdopts")
            _cargo_lane "$lane" force test --features stdopts --test "uat_stdopts"
            return $?
            ;;
        "uat-glyphs")
            _cargo_lane "$lane" force test --features visuals --test "uat_main"
            return $?
            ;;
        "uat-visual")
            _with_env \
                "RSB_COLORS=simple,status,named,bg" \
                "RSB_COLOR=always" \
                -- \
                _cargo_lane "$lane" force test --features visuals --test "uat_main"
            return $?
            ;;
        "uat-prompts")
            _cargo_lane "$lane" force test --features visuals --test "uat_main"
            return $?
            ;;
    esac

    return 1
}

_run_dynamic() {
    local lane="$1"
    local mod="${2-}"

    if [[ -n "$mod" ]]; then
        __stderr "‚ùå Unknown lane '$lane' for module '$mod'"
        return 1
    fi

    _run_header "$lane"
    _run_exec "$lane" "$lane"
    return $?
}

_run_lane() {
    local lane="$1"
    local mod="${2-}"
    local base="${TESTSH_TEST_MAP[$lane]:-$lane}"

    if [[ -n "$mod" ]]; then
        _run_module "$lane" "$mod" "$base"
        return $?
    fi

    if [[ "${TESTSH_PROFILE}" == "rsb" ]]; then
        if _run_lane_rsb "$lane" "$base"; then
            return 0
        fi
    fi

    _run_header "$lane"
    _run_exec "$lane" "$base"
    return $?
}

_run_adhoc() {
    local name="$1"
    local dir="$TESTSH_TEST_ROOT/_adhoc"

    if [[ ! -d "$dir" ]]; then
        __stderr "‚ùå Adhoc directory missing: ${dir#$TESTSH_PROJECT_ROOT/}"
        return 1
    fi

    if [[ -z "$name" ]]; then
        _emit_boxy "$(_adhoc_summary)" "info" "üß™ Adhoc"
        return 0
    fi

    local path=""
    if [[ -f "$dir/$name.rs" ]]; then
        path="$dir/$name.rs"
    elif [[ -f "$dir/$name.sh" ]]; then
        path="$dir/$name.sh"
    elif [[ -f "$dir/$name" ]]; then
        path="$dir/$name"
    fi

    if [[ -z "$path" ]]; then
        __stderr "‚ùå Adhoc test not found: $name"
        return 1
    fi

    __stderr "üß™ Running adhoc test: $name"
    __stderr "üìÅ ${path#$TESTSH_PROJECT_ROOT/}"
    __stderr ""

    local res=0
    case "$path" in
        *.rs)
            local base
            base="$(basename "$path" .rs)"
            ( cd "$TESTSH_PROJECT_ROOT" && __cargo test --test "_adhoc_$base" -- --nocapture )
            res=$?
            ;;
        *.sh)
            ( cd "$TESTSH_PROJECT_ROOT" && bash "$path" )
            res=$?
            ;;
        *)
            __stderr "‚ùå Unsupported adhoc target: $path"
            return 1
            ;;
    esac

    return $res
}

_adhoc_summary() {
    local dir="$TESTSH_TEST_ROOT/_adhoc"
    local msg="üß™ Adhoc tests\n\n"

    if [[ ! -d "$dir" ]]; then
        msg+="  ‚Ä¢ directory missing (tests/_adhoc)\n"
        printf '%s' "$msg"
        return 0
    fi

    local -a entries=()
    while IFS= read -r -d '' file; do
        entries+=("$(basename "$file")")
    done < <(find "$dir" -maxdepth 1 -type f \( -name '*.rs' -o -name '*.sh' -o -perm -u+x \) -print0 | sort -z)

    if (( ${#entries[@]} == 0 )); then
        msg+="  ‚Ä¢ none found\n"
    else
        local item
        for item in "${entries[@]}"; do
            msg+="  ‚Ä¢ $item\n"
        done
    fi

    printf '%s' "$msg"
}

# === 55_profile.sh ===
_load_profile() {
    local prof="${TESTSH_PROFILE:-${TESTSH_TEST_PROFILE:-}}"
    [[ -z "$prof" ]] && { TESTSH_PROFILE=""; return 0; }

    prof="${prof,,}"
    TESTSH_PROFILE="$prof"

    case "$prof" in
        rsb)
            _profile_rsb
            ;;
        default|generic)
            ;;
        *)
            __stderr "‚ö†Ô∏è Unknown profile: $prof"
            ;;
    esac
}

_profile_rsb() {
    TESTSH_TEST_MAP[sanity]="sanity"
    TESTSH_TEST_MAP[param]="sanity"
    TESTSH_TEST_MAP["param-helpers"]="sanity"
    TESTSH_TEST_MAP["param-uat"]="uat"
    TESTSH_TEST_MAP[macros]="sanity"
    TESTSH_TEST_MAP[context]="uat"
    TESTSH_TEST_MAP[global]="uat"
    TESTSH_TEST_MAP["host-env"]="sanity"
    TESTSH_TEST_MAP["host-paths"]="sanity"
    TESTSH_TEST_MAP[cli]="sh/cli_macros_e2e"
    TESTSH_TEST_MAP[args]="sanity"
    TESTSH_TEST_MAP[stdopts]="sanity"
    TESTSH_TEST_MAP["uat-colors"]="uat"
    TESTSH_TEST_MAP["uat-colors-macros"]="uat"
    TESTSH_TEST_MAP["uat-stdopts"]="uat"
    TESTSH_TEST_MAP["uat-glyphs"]="uat"
    TESTSH_TEST_MAP["uat-visual"]="uat"
    TESTSH_TEST_MAP["uat-prompts"]="uat"
    TESTSH_TEST_MAP[threads]="sanity"
    TESTSH_TEST_MAP["uat-threads"]="uat"
    TESTSH_TEST_MAP[bash]="sanity"
    TESTSH_TEST_MAP["uat-bash"]="uat"
    TESTSH_TEST_MAP[colors]="uat"
    TESTSH_TEST_MAP["colors-runtime"]="uat"
    TESTSH_TEST_MAP[bootstrap]="sanity"
    TESTSH_TEST_MAP[smoke]="smoke"
    TESTSH_TEST_MAP[integration]="integration"
    TESTSH_TEST_MAP[regression]="regression"
    TESTSH_TEST_MAP[defects]="regression"

    local tech_root="$TESTSH_DOC_ROOT/tech"
    local dev_root="$tech_root/development"
    local ref_root="$tech_root/reference"
    local feat_root="$tech_root/features"

    if [[ -f "$dev_root/TEST_ORGANIZATION.md" ]]; then
        TESTSH_DOC_OVERRIDE[org]="$dev_root/TEST_ORGANIZATION.md"
    elif [[ -f "$TESTSH_DOC_ROOT/rebel/TEST_ORGANIZATION.md" ]]; then
        TESTSH_DOC_OVERRIDE[org]="$TESTSH_DOC_ROOT/rebel/TEST_ORGANIZATION.md"
    fi

    if [[ -f "$dev_root/HOWTO_UPDATE_RSB.md" ]]; then
        TESTSH_DOC_OVERRIDE[howto]="$dev_root/HOWTO_UPDATE_RSB.md"
    elif [[ -f "$TESTSH_DOC_ROOT/development/HOWTO_UPDATE_RSB.md" ]]; then
        TESTSH_DOC_OVERRIDE[howto]="$TESTSH_DOC_ROOT/development/HOWTO_UPDATE_RSB.md"
    fi

    if [[ -f "$dev_root/MODULE_SPEC.md" ]]; then
        TESTSH_DOC_OVERRIDE[modules]="$dev_root/MODULE_SPEC.md"
        TESTSH_DOC_OVERRIDE[spec]="$dev_root/MODULE_SPEC.md"
    elif [[ -f "$TESTSH_DOC_ROOT/rebel/MODULE_SPEC.md" ]]; then
        TESTSH_DOC_OVERRIDE[modules]="$TESTSH_DOC_ROOT/rebel/MODULE_SPEC.md"
        TESTSH_DOC_OVERRIDE[spec]="$TESTSH_DOC_ROOT/rebel/MODULE_SPEC.md"
    fi

    if [[ -f "$dev_root/PRELUDE_POLICY.md" ]]; then
        TESTSH_DOC_OVERRIDE[prelude]="$dev_root/PRELUDE_POLICY.md"
    elif [[ -f "$TESTSH_DOC_ROOT/rebel/PRELUDE_POLICY.md" ]]; then
        TESTSH_DOC_OVERRIDE[prelude]="$TESTSH_DOC_ROOT/rebel/PRELUDE_POLICY.md"
    fi

    if [[ -f "$feat_root/FEATURES_OPTIONS.md" ]]; then
        TESTSH_DOC_OVERRIDE[features]="$feat_root/FEATURES_OPTIONS.md"
    elif [[ -f "$TESTSH_DOC_ROOT/rebel/FEATURES_OPTIONS.md" ]]; then
        TESTSH_DOC_OVERRIDE[features]="$TESTSH_DOC_ROOT/rebel/FEATURES_OPTIONS.md"
    fi

    if [[ -f "$ref_root/BASHFX-v3.md" ]]; then
        TESTSH_DOC_OVERRIDE["bashfx-v3"]="$ref_root/BASHFX-v3.md"
        TESTSH_DOC_OVERRIDE[bashfx]="$ref_root/BASHFX-v3.md"
    elif [[ -f "$TESTSH_DOC_ROOT/bashfx/BASHFX-v3.md" ]]; then
        TESTSH_DOC_OVERRIDE["bashfx-v3"]="$TESTSH_DOC_ROOT/bashfx/BASHFX-v3.md"
        TESTSH_DOC_OVERRIDE[bashfx]="$TESTSH_DOC_ROOT/bashfx/BASHFX-v3.md"
    fi

    if [[ -f "$ref_root/RSB_TEST_RUNNER.md" ]]; then
        TESTSH_DOC_OVERRIDE[rsb]="$ref_root/RSB_TEST_RUNNER.md"
        TESTSH_DOC_OVERRIDE[runner]="$ref_root/RSB_TEST_RUNNER.md"
    elif [[ -f "$TESTSH_DOC_ROOT/reference/RSB_TEST_RUNNER.md" ]]; then
        TESTSH_DOC_OVERRIDE[rsb]="$TESTSH_DOC_ROOT/reference/RSB_TEST_RUNNER.md"
        TESTSH_DOC_OVERRIDE[runner]="$TESTSH_DOC_ROOT/reference/RSB_TEST_RUNNER.md"
    fi
}

# === 60_docs.sh ===
_docs_overview() {
    local root="$TESTSH_DOC_ROOT"

    if [[ -z "$root" || ! -d "$root" ]]; then
        __stderr "‚ùå Documentation root not found"
        return 1
    fi

    local msg="üìö Documentation Hub\n\nProfile: ${TESTSH_PROFILE:-default}\nRoot: ${root#$TESTSH_PROJECT_ROOT/}\n\nSections:\n"
    local dir
    while IFS= read -r dir; do
        local name="${dir#$root/}"
        msg+="  ‚Ä¢ $name/\n"
    done < <(find "$root" -maxdepth 1 -mindepth 1 -type d | sort)

    msg+="\nRoot Files:\n"
    local file
    while IFS= read -r file; do
        local name="$(basename "$file")"
        msg+="  ‚Ä¢ $name\n"
    done < <(find "$root" -maxdepth 1 -type f -name '*.md' | sort)

    msg+="\nUsage:\n  test.sh docs <topic>\n\nExamples:\n  test.sh docs overview\n  test.sh docs getting_started\n  test.sh docs reference/BASHFX-v3\n"

    _emit_boxy "$msg" "info" "üìö Documentation"
}

_docs_resolve() {
    local topic="$1"
    local root="$TESTSH_DOC_ROOT"

    if [[ -z "$root" || ! -d "$root" ]]; then
        return 1
    fi

    local path=""
    local key

    key="${topic,,}"
    if [[ "$topic" != */* && -n "${TESTSH_DOC_OVERRIDE[$key]+x}" ]]; then
        local mapped="${TESTSH_DOC_OVERRIDE[$key]}"
        if [[ -f "$mapped" ]]; then
            printf '%s\n' "$mapped"
            return 0
        fi
    fi

    if [[ -f "$root/$topic" ]]; then
        path="$root/$topic"
    elif [[ -f "$root/$topic.md" ]]; then
        path="$root/$topic.md"
    elif [[ "$topic" == */* && -f "$root/$topic.md" ]]; then
        path="$root/$topic.md"
    else
        path=$(find "$root" -maxdepth 3 -type f -iname "${topic}.md" | head -n 1)
        if [[ -z "$path" ]]; then
            path=$(find "$root" -maxdepth 3 -type f -iname "${topic}_*.md" | head -n 1)
        fi
    fi

    if [[ -n "$path" && -f "$path" ]]; then
        printf '%s\n' "$path"
        return 0
    fi

    return 1
}

_docs_show() {
    local topic="$1"
    local path
    if ! path=$(_docs_resolve "$topic"); then
        __stderr "‚ùå Documentation topic not found: $topic"
        return 1
    fi

    local title
    title="üìÑ ${path#$TESTSH_PROJECT_ROOT/}"

    if [[ -n "$TESTSH_BOXY_BIN" ]]; then
        cat "$path" | "$TESTSH_BOXY_BIN" --theme info --title "$title" --width max
    else
        __stderr "$title"
        __stderr "----------------------------------------"
        cat "$path"
    fi

    __stderr ""
}

_docs_seed_default() {
    local root="$TESTSH_DOC_ROOT"
    [[ -d "$root" ]] || return 0

    local tech_root="$root/tech"
    local dev_root="$tech_root/development"
    local ref_root="$tech_root/reference"
    local feat_root="$tech_root/features"

    if [[ -f "$ref_root/BASHFX-v3.md" ]]; then
        TESTSH_DOC_OVERRIDE[bashfx]="$ref_root/BASHFX-v3.md"
        TESTSH_DOC_OVERRIDE[legendary]="$ref_root/BASHFX-v3.md"
        TESTSH_DOC_OVERRIDE[bashfx_ref]="$ref_root/BASHFX-v3.md"
    elif [[ -f "$root/bashfx/BASHFX-v3.md" ]]; then
        TESTSH_DOC_OVERRIDE[bashfx]="$root/bashfx/BASHFX-v3.md"
        TESTSH_DOC_OVERRIDE[legendary]="$root/bashfx/BASHFX-v3.md"
        TESTSH_DOC_OVERRIDE[bashfx_ref]="$root/bashfx/BASHFX-v3.md"
    fi

    if [[ -f "$root/README.md" ]]; then
        TESTSH_DOC_OVERRIDE[readme]="$root/README.md"
    fi

    if [[ -f "$dev_root/TEST_ORGANIZATION.md" ]]; then
        TESTSH_DOC_OVERRIDE[org]="$dev_root/TEST_ORGANIZATION.md"
        TESTSH_DOC_OVERRIDE[organization]="$dev_root/TEST_ORGANIZATION.md"
    elif [[ -f "$root/rebel/TEST_ORGANIZATION.md" ]]; then
        TESTSH_DOC_OVERRIDE[org]="$root/rebel/TEST_ORGANIZATION.md"
        TESTSH_DOC_OVERRIDE[organization]="$root/rebel/TEST_ORGANIZATION.md"
    fi

    if [[ -f "$dev_root/HOWTO_UPDATE_RSB.md" ]]; then
        TESTSH_DOC_OVERRIDE[howto]="$dev_root/HOWTO_UPDATE_RSB.md"
        TESTSH_DOC_OVERRIDE[update_rsb]="$dev_root/HOWTO_UPDATE_RSB.md"
    elif [[ -f "$root/development/HOWTO_UPDATE_RSB.md" ]]; then
        TESTSH_DOC_OVERRIDE[howto]="$root/development/HOWTO_UPDATE_RSB.md"
        TESTSH_DOC_OVERRIDE[update_rsb]="$root/development/HOWTO_UPDATE_RSB.md"
    fi

    if [[ -f "$ref_root/RSB_TEST_RUNNER.md" ]]; then
        TESTSH_DOC_OVERRIDE[rsb]="$ref_root/RSB_TEST_RUNNER.md"
        TESTSH_DOC_OVERRIDE[runner]="$ref_root/RSB_TEST_RUNNER.md"
    elif [[ -f "$root/reference/RSB_TEST_RUNNER.md" ]]; then
        TESTSH_DOC_OVERRIDE[rsb]="$root/reference/RSB_TEST_RUNNER.md"
        TESTSH_DOC_OVERRIDE[runner]="$root/reference/RSB_TEST_RUNNER.md"
    fi

    if [[ -f "$dev_root/MODULE_SPEC.md" ]]; then
        TESTSH_DOC_OVERRIDE[modules]="$dev_root/MODULE_SPEC.md"
        TESTSH_DOC_OVERRIDE[spec]="$dev_root/MODULE_SPEC.md"
    elif [[ -f "$root/rebel/MODULE_SPEC.md" ]]; then
        TESTSH_DOC_OVERRIDE[modules]="$root/rebel/MODULE_SPEC.md"
        TESTSH_DOC_OVERRIDE[spec]="$root/rebel/MODULE_SPEC.md"
    fi

    if [[ -f "$dev_root/PRELUDE_POLICY.md" ]]; then
        TESTSH_DOC_OVERRIDE[prelude]="$dev_root/PRELUDE_POLICY.md"
    elif [[ -f "$root/rebel/PRELUDE_POLICY.md" ]]; then
        TESTSH_DOC_OVERRIDE[prelude]="$root/rebel/PRELUDE_POLICY.md"
    fi

    if [[ -f "$feat_root/FEATURES_OPTIONS.md" ]]; then
        TESTSH_DOC_OVERRIDE[features]="$feat_root/FEATURES_OPTIONS.md"
    elif [[ -f "$root/rebel/FEATURES_OPTIONS.md" ]]; then
        TESTSH_DOC_OVERRIDE[features]="$root/rebel/FEATURES_OPTIONS.md"
    fi
}

# === 65_listing.sh ===
_list_tests() {
    local -a list=()
    local key
    for key in "${!TESTSH_TEST_MAP[@]}"; do
        list+=("$key")
    done

    local file
    for file in "$TESTSH_TEST_ROOT"/*.rs "$TESTSH_TEST_ROOT"/*.sh; do
        [[ ! -f "$file" ]] && continue
        local name
        name="$(basename "$file")"
        name="${name%.rs}"
        name="${name%.sh}"
        [[ -n "${TESTSH_TEST_MAP[$name]+x}" ]] && continue
        list+=("$name")
    done

    printf '%s\n' "${list[@]}" | sort -u
}

# === 70_org.sh ===
_org_validate() {
    local mode="${1:-run}"

    if [[ "${TESTSH_FLAGS[skip_enforcement]}" == "true" ]]; then
        return 0
    fi

    if [[ "${TESTSH_FLAGS[override]}" == "true" && "$mode" != "lint" ]]; then
        _emit_override_warning
    fi

    __stderr "üîç Validating test structure..."

    # Organized violation buckets
    local -a arr_name=()
    local -a arr_sanity=()
    local -a arr_uat=()
    local -a arr_dir=()
    local -a arr_entry=()
    local -a arr_root=()

    local rx_cat="unit|sanity|smoke|integration|e2e|uat|chaos|bench|regression"
    local -a arr_required=(sanity smoke unit integration e2e uat chaos bench regression)

    local dir_tests="$TESTSH_TEST_ROOT"
    local dir_src="$TESTSH_SRC_ROOT"

    # Wrapper naming checks
    local file
    for file in "$dir_tests"/*.rs; do
        [[ ! -f "$file" ]] && continue

        local name
        name="${file##*/}"
        name="${name%.rs}"

        [[ "$name" =~ ^(_|dev_) ]] && continue
        [[ "$name" =~ ^_ ]] && continue

        if [[ ! "$name" =~ ^($rx_cat)(_[a-z_]+)?$ ]]; then
            arr_name+=("${file#$TESTSH_PROJECT_ROOT/}")
        fi
    done

    local -a arr_exclude=(
        "_*"
        "dev_*"
        "prelude*"
        "dummy_*"
        "lib"
        "main"
        "macros"
        "streamable"
        "xcls"
    )

    is_excluded_module() {
        local lbl="$1"
        local pat
        for pat in "${arr_exclude[@]}"; do
            if [[ "$lbl" == $pat ]]; then
                if [[ "$pat" == "dev_*" && "$lbl" == "dev" ]]; then
                    return 1
                fi
                return 0
            fi
        done
        return 1
    }

    local dir
    for dir in "$dir_src"/*/; do
        [[ ! -d "$dir" ]] && continue
        [[ ! -f "${dir}mod.rs" ]] && continue

        local lbl
        lbl="$(basename "$dir")"

        if is_excluded_module "$lbl"; then
            continue
        fi

        if [[ ! -f "$dir_tests/sanity_${lbl}.rs" && ! -f "$dir_tests/sanity/${lbl}.rs" && ! -f "$dir_tests/sanity/sanity_${lbl}.rs" ]]; then
            arr_sanity+=("$lbl")
        fi

        if [[ ! -f "$dir_tests/uat_${lbl}.rs" && ! -f "$dir_tests/uat/${lbl}.rs" && ! -f "$dir_tests/uat/uat_${lbl}.rs" ]]; then
            arr_uat+=("$lbl")
        fi
    done

    local cat
    for cat in "${arr_required[@]}"; do
        if [[ ! -f "$dir_tests/${cat}.rs" && ! -f "$dir_tests/${cat}.sh" ]]; then
            arr_entry+=("$cat")
        fi
    done

    for file in "$dir_tests"/*.rs "$dir_tests"/*.sh; do
        [[ ! -f "$file" ]] && continue

        local name
        name="${file##*/}"
        name="${name%.rs}"
        name="${name%.sh}"

        [[ "$name" =~ ^(_|dev_) ]] && continue
        [[ "$name" =~ ^_ ]] && continue

        local ok="false"
        for cat in "${arr_required[@]}"; do
            if [[ "$name" == "$cat" ]]; then
                ok="true"
                break
            fi
        done

        if [[ "$ok" != true && "$name" =~ ^($rx_cat)_[a-z_]+$ ]]; then
            ok="true"
        fi

        if [[ "$ok" != true ]]; then
            arr_root+=("${file#$TESTSH_PROJECT_ROOT/}")
        fi
    done

    for dir in "$dir_tests"/*/; do
        [[ ! -d "$dir" ]] && continue

        local name
        name="$(basename "$dir")"

        if [[ ! "$name" =~ ^($rx_cat|sh|_archive|_adhoc)$ ]]; then
            arr_dir+=("${dir#$TESTSH_PROJECT_ROOT/}")
        fi
    done

    local total
    total=$((${#arr_name[@]} + ${#arr_sanity[@]} + ${#arr_uat[@]} + ${#arr_dir[@]} + ${#arr_entry[@]} + ${#arr_root[@]}))

    if [[ $total -gt 0 ]]; then
        if [[ "${TESTSH_FLAGS[violations]}" == "true" ]]; then
            __stderr "üìã Test Organization Violations Report ($total total)"
            __stderr "================================================================"
            __stderr ""

            if [[ ${#arr_name[@]} -gt 0 ]]; then
                __stderr "üè∑Ô∏è  NAMING VIOLATIONS (${#arr_name[@]} files)"
                __stderr "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                __stderr "Issue: Test wrapper files don't follow naming pattern"
                __stderr "Required: <category>_<module>.rs (e.g., sanity_com.rs, uat_math.rs)"
                __stderr "Valid categories: unit, sanity, smoke, integration, e2e, uat, chaos, bench"
                __stderr ""
                local i
                for ((i = 0; i < ${#arr_name[@]}; i++)); do
                    printf '%3d. %s\n' "$((i + 1))" "${arr_name[i]}"
                done >&2
                __stderr ""
                __stderr "Fix: Rename files to match pattern (e.g., com_sanity.rs ‚Üí sanity_com.rs)"
                __stderr ""
            fi

            if [[ ${#arr_sanity[@]} -gt 0 ]]; then
                __stderr "üö® MISSING SANITY TESTS (${#arr_sanity[@]} modules)"
                __stderr "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                __stderr "Issue: Modules without required sanity tests"
                __stderr "Required: Every module must have sanity tests for core functionality"
                __stderr ""
                local i
                for ((i = 0; i < ${#arr_sanity[@]}; i++)); do
                    printf "%3d. Module '%s' (create: tests/sanity_%s.rs)\n" "$((i + 1))" "${arr_sanity[i]}" "${arr_sanity[i]}"
                done >&2
                __stderr ""
                __stderr "Fix: Create sanity test files for each module"
                __stderr ""
            fi

            if [[ ${#arr_uat[@]} -gt 0 ]]; then
                __stderr "üé≠ MISSING UAT TESTS (${#arr_uat[@]} modules)"
                __stderr "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                __stderr "Issue: Modules without required visual UAT/ceremony tests"
                __stderr "Required: Every module must have UAT tests for visual demonstrations"
                __stderr ""
                local i
                for ((i = 0; i < ${#arr_uat[@]}; i++)); do
                    printf "%3d. Module '%s' (create: tests/uat_%s.rs)\n" "$((i + 1))" "${arr_uat[i]}" "${arr_uat[i]}"
                done >&2
                __stderr ""
                __stderr "Fix: Create UAT test files with visual demonstrations for each module"
                __stderr ""
            fi

            if [[ ${#arr_entry[@]} -gt 0 ]]; then
                __stderr "üìã MISSING CATEGORY ENTRY FILES (${#arr_entry[@]} categories)"
                __stderr "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                __stderr "Issue: Missing category-level test orchestrators"
                __stderr "Required: Each category needs an entry file (e.g., smoke.rs, unit.rs)"
                __stderr ""
                local i
                for ((i = 0; i < ${#arr_entry[@]}; i++)); do
                    printf "%3d. Category '%s' (create: tests/%s.rs)\n" "$((i + 1))" "${arr_entry[i]}" "${arr_entry[i]}"
                done >&2
                __stderr ""
                __stderr "Fix: Create category entry files for cross-module integration tests"
                __stderr ""
            fi

            if [[ ${#arr_root[@]} -gt 0 ]]; then
                __stderr "üö´ UNAUTHORIZED ROOT FILES (${#arr_root[@]} files)"
                __stderr "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                __stderr "Issue: Files in tests/ root that don't follow organization rules"
                __stderr "Allowed: <category>.rs or <category>_<module>.rs only"
                __stderr ""
                local i
                for ((i = 0; i < ${#arr_root[@]}; i++)); do
                    printf '%3d. %s\n' "$((i + 1))" "${arr_root[i]}"
                done >&2
                __stderr ""
                __stderr "Fix: Rename to pattern, move to tests/_adhoc/, or move to tests/_archive/"
                __stderr ""
            fi

            if [[ ${#arr_dir[@]} -gt 0 ]]; then
                __stderr "üìÅ INVALID DIRECTORIES (${#arr_dir[@]} directories)"
                __stderr "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                __stderr "Issue: Test directories don't match approved organization"
                __stderr "Valid: unit/, sanity/, smoke/, integration/, e2e/, uat/, chaos/, bench/, regression/, sh/, _archive/, _adhoc/"
                __stderr ""
                local i
                for ((i = 0; i < ${#arr_dir[@]}; i++)); do
                    printf '%3d. %s\n' "$((i + 1))" "${arr_dir[i]}"
                done >&2
                __stderr ""
                __stderr "Fix: Move tests to approved category directories or rename to _archive/"
                __stderr ""
            fi

            local fix_msg="VIOLATION SUMMARY & FIXES\n\nTotal Violations: $total\n‚Ä¢ Naming issues: ${#arr_name[@]}\n‚Ä¢ Missing sanity tests: ${#arr_sanity[@]}\n‚Ä¢ Missing UAT tests: ${#arr_uat[@]}\n‚Ä¢ Missing category entries: ${#arr_entry[@]}\n‚Ä¢ Unauthorized root files: ${#arr_root[@]}\n‚Ä¢ Invalid directories: ${#arr_dir[@]}\n\nQUICK FIXES:\n‚Ä¢ Run './bin/test.sh lint' for detailed analysis\n‚Ä¢ Use '--override' for emergency bypass\n‚Ä¢ Follow naming pattern: <category>_<module>.rs\n‚Ä¢ Create missing sanity tests for all modules"

            _emit_boxy "$fix_msg" "warning" "üìä Test Organization Fix Guide"
            return 1
        fi

        if [[ "${TESTSH_FLAGS[strict]}" == "true" && "${TESTSH_FLAGS[override]}" != "true" ]]; then
            local err="üö´ TEST EXECUTION BLOCKED üö´\n\nTest organization violations detected ($total total):\n‚Ä¢ Naming issues: ${#arr_name[@]}\n‚Ä¢ Missing sanity tests: ${#arr_sanity[@]}\n‚Ä¢ Missing UAT tests: ${#arr_uat[@]}\n‚Ä¢ Missing category entries: ${#arr_entry[@]}\n‚Ä¢ Unauthorized root files: ${#arr_root[@]}\n‚Ä¢ Invalid directories: ${#arr_dir[@]}\n\nSOLUTION OPTIONS:\n‚Ä¢ Fix violations and re-run tests\n‚Ä¢ Use --violations flag to see complete organized list\n‚Ä¢ Use --override flag for emergency bypass with warnings\n‚Ä¢ Use --skip-enforcement to disable validation entirely\n\nTests cannot proceed until organization is compliant."

            _emit_boxy "$err" "error" "‚ùå Test Organization Violations"
            return 1
        elif [[ "${TESTSH_FLAGS[override]}" == "true" ]]; then
            local warn_msg="Proceeding with violations in override mode ($total total):\n\n‚Ä¢ Naming issues: ${#arr_name[@]}\n‚Ä¢ Missing sanity tests: ${#arr_sanity[@]}\n‚Ä¢ Missing UAT tests: ${#arr_uat[@]}\n‚Ä¢ Missing category entries: ${#arr_entry[@]}\n‚Ä¢ Unauthorized root files: ${#arr_root[@]}\n‚Ä¢ Invalid directories: ${#arr_dir[@]}\n\nFix these violations when possible.\nUse --violations flag to see complete organized list."

            _emit_boxy "$warn_msg" "warning" "‚ö†Ô∏è  Organization Violations (Override Active)"
        else
            __stderr "‚ö†Ô∏è  Test structure warnings ($total total):"
            __stderr "   ‚Ä¢ Naming issues: ${#arr_name[@]}"
            __stderr "   ‚Ä¢ Missing sanity tests: ${#arr_sanity[@]}"
            __stderr "   ‚Ä¢ Missing UAT tests: ${#arr_uat[@]}"
            __stderr "   ‚Ä¢ Missing category entries: ${#arr_entry[@]}"
            __stderr "   ‚Ä¢ Unauthorized root files: ${#arr_root[@]}"
            __stderr "   ‚Ä¢ Invalid directories: ${#arr_dir[@]}"
            __stderr "   Use --violations flag for detailed breakdown"
            __stderr ""
        fi
        return 0
    fi

    local ok_msg="üéâ ZERO TEST VIOLATIONS ACHIEVED! üéâ\n\nTest framework status: FULLY COMPLIANT\n\nThe RSB test ecosystem is now perfectly organized and ready for\ncomprehensive validation across all modules and categories.\n\nüèÜ Outstanding work achieving complete test compliance! üèÜ"

    _emit_boxy "$ok_msg" "success" "üéØ RSB TEST ORGANIZATION: PERFECT COMPLIANCE"
    return 0
}


__stderr() {
    printf '%s\n' "$*" >&2
}

__todo() {
    local area="$1"
    __stderr "TODO: implement $area"
    return 99
}

# === 80_commands.sh ===
dispatch() {
    local cmd="${1:-$TESTSH_DEFAULT_COMMAND}"
    shift || true

    case "$cmd" in
        help) do_help "$@" ;;
        status) do_status "$@" ;;
        lint) do_lint "$@" ;;
        run) do_run "$@" ;;
        docs) do_docs "$@" ;;
        list) do_list "$@" ;;
        version) do_version "$@" ;;
        logo) do_logo "$@" ;;
        *)
            __stderr "Unknown command: $cmd"
            do_help
            return 1
            ;;
    esac
}

do_help() {
    cat <<'USAGE'
testsh :: Legendary test runner for Rebel/BashFx

Usage:
  test.sh [options] <command> [args]

Commands:
  status         Validate organization and show summary
  lint           Run strict organization lint checks
  run <lane>     Execute a test lane (optionally: run <lane> <module>)
  run adhoc <t>  Execute tests/_adhoc/<t>.rs|.sh
  docs [topic]   Show documentation overview or a specific topic
  list           List discovered test lanes and wrappers
  version        Print version metadata
  help           Show this help text

Options:
  --help, -h     Show help
  --version,-v   Show version
  --verbose      Verbose run output (exported as TESTSH_RUN_VERBOSE)
  --quick        Prefer quick lanes (default)
  --comprehensive|--full  Prefer comprehensive lanes
  --strict        Enforce organization (default)
  --skip-enforcement  Skip organization validation
  --override      Run despite violations (shows warnings)
  --violations    Emit violation report and exit
  --profile=<p>   Load profile overlays (e.g., --profile=rsb)
  --rsb           Shortcut for --profile=rsb

Examples:
  test.sh run sanity
  test.sh run uat math
  test.sh run adhoc demo
  test.sh docs reference/BASHFX-v3
  test.sh --profile=rsb list
  test.sh list
USAGE
}

do_status() {
    _ensure_environment || return 1

    local res=0
    if ! _org_validate "status"; then
        res=1
    fi

    local mode="quick"
    [[ "${TESTSH_FLAGS[comprehensive]}" == "true" ]] && mode="comprehensive"

    local strict_state="on"
    [[ "${TESTSH_FLAGS[strict]}" == "false" ]] && strict_state="off"

    local override_state="disabled"
    [[ "${TESTSH_FLAGS[override]}" == "true" ]] && override_state="enabled"

    local -a lns=()
    if ! mapfile -t lns < <(_list_tests 2>/dev/null); then
        lns=()
    fi

    local cnt=${#lns[@]}
    local doc="(missing)"
    if [[ -n "$TESTSH_DOC_ROOT" && -d "$TESTSH_DOC_ROOT" ]]; then
        doc="${TESTSH_DOC_ROOT#$TESTSH_PROJECT_ROOT/}"
    fi

    local theme="success"
    local result_text="‚úÖ organization compliant"
    if ((res != 0)); then
        theme="warning"
        result_text="‚ö†Ô∏è  violations detected"
    fi

    local msg
    printf -v msg 'üß≠ fx-testsh status\n\nProject : %s\nProfile : %s\nMode    : %s\nTests   : %d\nDocs    : %s\nStrict  : %s\nOverride: %s\nResult  : %s\n' \
        "${TESTSH_PROJECT_ROOT##*/}" "${TESTSH_PROFILE:-default}" "$mode" "$cnt" "$doc" "$strict_state" "$override_state" "$result_text"

    if ((cnt > 0)); then
        msg+=$'\nLanes:\n'
        local limit=8
        local i
        for ((i = 0; i < cnt && i < limit; i++)); do
            msg+="  ‚Ä¢ ${lns[i]}\n"
        done
        if ((cnt > limit)); then
            msg+="  ‚Ä¢ ... (${cnt} total)\n"
        fi
    else
        msg+=$'\nLanes:\n  ‚Ä¢ none detected\n'
    fi

    _emit_boxy "$msg" "$theme" "üß≠ Status"
    return $res
}

do_lint() {
    _ensure_environment || return 1

    __stderr "üßπ Linting test organization..."
    __stderr ""

    local previous_strict="${TESTSH_FLAGS[strict]}"
    local previous_skip="${TESTSH_FLAGS[skip_enforcement]}"

    TESTSH_FLAGS[strict]=true
    TESTSH_FLAGS[skip_enforcement]=false

    if _org_validate "lint"; then
        __stderr "‚úÖ Test organization lint completed"
        TESTSH_FLAGS[strict]="$previous_strict"
        TESTSH_FLAGS[skip_enforcement]="$previous_skip"
        return 0
    fi

    TESTSH_FLAGS[strict]="$previous_strict"
    TESTSH_FLAGS[skip_enforcement]="$previous_skip"
    return 1
}

do_run() {
    _ensure_environment || return 1

    if ! _org_validate "run"; then
        [[ "${TESTSH_FLAGS[override]}" == "true" ]] || return 1
    fi

    _run_env

    local run_args="$*"
    [[ -z "$run_args" ]] && run_args="(no lane provided)"

    local status=0
    set +e
    dispatch_run "$@"
    status=$?
    set -e

    local mode="quick"
    [[ "${TESTSH_FLAGS[comprehensive]}" == "true" ]] && mode="comprehensive"

    local strict_state="on"
    [[ "${TESTSH_FLAGS[strict]}" == "false" ]] && strict_state="off"

    local override_state="disabled"
    local override_active=false
    if [[ "${TESTSH_FLAGS[override]}" == "true" ]]; then
        override_state="enabled"
        override_active=true
    fi

    local theme="success"
    local result_text="‚úÖ run completed"
    if ((status != 0)); then
        theme="error"
        result_text="‚ùå run failed (exit $status)"
    elif [[ "$override_active" == true ]]; then
        theme="warning"
        result_text="‚ö†Ô∏è  completed under override"
    fi

    local summary
    printf -v summary 'Command : run %s\nProfile : %s\nMode    : %s\nStrict  : %s\nOverride: %s\nResult  : %s' \
        "$run_args" "${TESTSH_PROFILE:-default}" "$mode" "$strict_state" "$override_state" "$result_text"

    _emit_boxy "$summary" "$theme" "üèÅ Run Summary"

    return $status
}

dispatch_run() {
    local lane="${1:-}"
    local mod="${2-}"

    if [[ -z "$lane" ]]; then
        __stderr "‚ùå Run lane required"
        __stderr "   Usage: test.sh run <lane> [module]"
        return 1
    fi

    case "$lane" in
        adhoc)
            _run_adhoc "$mod"
            return $?
            ;;
    esac

    if [[ -n "${TESTSH_TEST_MAP[$lane]+x}" ]]; then
        _run_lane "$lane" "$mod"
        return $?
    fi

    _run_dynamic "$lane" "$mod"
}

do_docs() {
    dispatch_docs "$@"
}

dispatch_docs() {
    local topic="${1:-}"

    if [[ -z "$topic" ]]; then
        _docs_overview
        return $?
    fi

    if [[ "${topic,,}" == "overview" ]]; then
        _docs_overview
        return $?
    fi

    _docs_show "$topic"
}

do_list() {
    _ensure_environment || return 1

    local msg="üóÇÔ∏è Available test lanes\n\n"
    while IFS= read -r line; do
        msg+="  ‚Ä¢ $line\n"
    done < <(_list_tests)

    local adhoc_summary
    adhoc_summary=$(_adhoc_summary)
    msg+="\n${adhoc_summary}\n"

    _emit_boxy "$msg" "info" "üóÇÔ∏è Test Lanes"
}


_get_version() {
    # Extract version from semv metadata
    local version
    version=$(grep "^# semv-version:" "$0" | cut -d' ' -f3)
    [[ -z "$version" ]] && version="unknown"
    echo "$version"
}

do_version() {
    printf "%s v%s\n" "$TESTSH_APP_NAME" "$(_get_version)"
    return 0
}

do_logo() {
    local logo="TEST.SH"
    if command -v figlet >/dev/null 2>&1; then
        figlet "$logo"
    else
        printf '[[ %s ]]\n' "$logo"
    fi
}

# =============================================================================
# usage / options / driver
# =============================================================================

# === 90_options.sh ===
options() {
    TESTSH_ARGS=()
    local arg

    while (($#)); do
        arg="$1"
        case "$arg" in
            --help|-h)
                TESTSH_FLAGS[help]=true
                ;;
            --version|-v)
                TESTSH_FLAGS[version]=true
                ;;
            --verbose)
                TESTSH_FLAGS[verbose]=true
                ;;
            --quick)
                TESTSH_FLAGS[quick]=true
                TESTSH_FLAGS[comprehensive]=false
                ;;
            --comprehensive|--full)
                TESTSH_FLAGS[quick]=false
                TESTSH_FLAGS[comprehensive]=true
                ;;
            --strict)
                TESTSH_FLAGS[strict]=true
                ;;
            --violations|--probs)
                TESTSH_FLAGS[violations]=true
                ;;
            --skip-enforcement|--skip)
                TESTSH_FLAGS[skip_enforcement]=true
                TESTSH_FLAGS[strict]=false
                ;;
            --override|--ov)
                TESTSH_FLAGS[override]=true
                TESTSH_FLAGS[strict]=false
                ;;
            --profile=*)
                TESTSH_PROFILE="${arg#--profile=}"
                ;;
            --profile)
                shift || break
                TESTSH_PROFILE="${1:-}"
                ;;
            --rsb)
                TESTSH_PROFILE="rsb"
                ;;
            --)
                shift
                TESTSH_ARGS+=("$@")
                break
                ;;
            --*)
                __stderr "Unknown option: $arg"
                TESTSH_FLAGS[help]=true
                ;;
            *)
                TESTSH_ARGS+=("$arg")
                ;;
        esac
        shift || break
    done
}


# === 99_main.sh ===
main() {
    _bootstrap_paths
    options "$@"
    _load_profile

    if [[ "${TESTSH_FLAGS[version]}" == "true" ]]; then
        do_version
        return 0
    fi

    if [[ "${TESTSH_FLAGS[help]}" == "true" ]]; then
        do_help
        return 0
    fi

    if [[ ${#TESTSH_ARGS[@]} -eq 0 ]]; then
        TESTSH_ARGS+=("$TESTSH_DEFAULT_COMMAND")
    fi

    dispatch "${TESTSH_ARGS[@]}"
}

main "$@"
