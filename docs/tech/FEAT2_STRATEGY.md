# feat2.py Strategy Document

Version: 1.0
Created: 2025-10-01
Status: Design Phase

## Overview

`feat2.py` is a generalized, repository-agnostic feature documentation tool that automatically discovers, inspects, and documents public API surfaces across codebases. It extends the original `feat.py` (RSB-specific) to work with any project structure through convention-over-configuration design.

## Core Concepts

### 1. Convention Over Configuration

**Default behavior** (zero config):
- Auto-detect repository root via `.git`, `Cargo.toml`, `package.json`, `pyproject.toml`
- Scan source tree (`src/`, `lib/`, `pkg/`) for feature modules
- Match features to documentation files using pattern heuristics
- Infer language from file extensions

**Optional configuration** (`.feat.toml`):
- Explicit feature-to-path mappings
- Custom documentation directory structure
- Language-specific parsing rules
- Exclusion patterns

### 2. Language Abstraction

**Parser Interface**:
```python
class Parser(ABC):
    @abstractmethod
    def parse_file(self, path: Path) -> List[Item]:
        """Extract public API items from source file"""

    @abstractmethod
    def supported_extensions(self) -> List[str]:
        """Return file extensions this parser handles"""
```

**Supported Languages**:
- **Rust** (implemented): `pub fn`, `pub struct`, `pub enum`, `pub trait`, `pub type`, `pub use`, `#[macro_export]`
- **Python** (planned): classes, functions, decorators, `__all__` exports
- **JavaScript/TypeScript** (stubbed): exports, interfaces, types - **NOT IMPLEMENTED**

### 3. Feature Discovery

**Auto-discovery algorithm**:
1. Scan configured source root (default: `src/`)
2. Identify top-level directories as potential features
3. For Rust: cross-reference with `Cargo.toml` `[features]` section
4. Build feature map: `{name: [paths]}`

**Manual override**:
- Explicit `[features]` table in `.feat.toml`
- Path globs for complex feature layouts
- Support for multi-module features

### 4. Documentation Integration

**Doc path resolution**:
1. Check `.feat.toml` for `doc_pattern`
2. Try common patterns:
   - `{docs_root}/FEATURES_{FEATURE}.md`
   - `{docs_root}/features/{feature}.md`
   - `{docs_root}/{feature}.md`
3. Fall back to user-specified path via CLI

**Sentinel block format**:
```markdown
<!-- feat:feature-name -->

_Generated by bin/feat2.py --update-doc._

* `src/feature/mod.rs`
  - fn example (line 42)
  - struct Config (line 15)

<!-- /feat:feature-name -->
```

## Configuration Schema

**File**: `.feat.toml` (repository root)

```toml
# Root directories
features_root = "src"           # Where feature code lives
docs_root = "docs/features"     # Where feature docs live

# Documentation file naming pattern
# Variables: {FEATURE}, {feature}, {feat}
doc_pattern = "FEATURES_{FEATURE}.md"

# Language support
languages = ["rust"]            # Active parsers

# Auto-discovery
auto_discover = true            # Scan source tree
discover_from_cargo = true      # Use Cargo.toml features

# Exclusion patterns (glob)
exclude = [
    "**/tests/**",
    "**/*_test.rs",
    "**/target/**",
]

# Explicit feature map (overrides auto-discovery)
[features]
global = ["src/global"]
strings = ["src/string", "src/utils.rs"]
cli = ["src/cli", "src/cli/macros.rs"]

# Language-specific settings
[parsers.rust]
include_private_in_pub_mod = false

[parsers.python]
respect_all_export = true       # Honor __all__ lists

[parsers.typescript]
# NOT IMPLEMENTED
```

## Architecture

### Module Structure

```
feat2.py
├── Config         # TOML parsing and validation
├── RepoContext    # Repository root detection
├── Parser (ABC)   # Language parser interface
│   ├── RustParser
│   ├── PythonParser
│   └── TSParser (stub)
├── Discovery      # Feature auto-discovery
├── Collector      # Item collection orchestrator
├── Renderer       # Output formatting
└── DocUpdater     # Markdown sentinel block management
```

### Data Model

```python
@dataclass
class Item:
    kind: str              # fn, struct, class, export, etc.
    name: str              # Identifier
    location: Path         # Source file
    line: int              # Line number
    extra: Optional[str]   # Context (e.g., "pub use foo::bar")
    language: str          # rust, python, typescript

@dataclass
class Feature:
    name: str              # Feature identifier
    paths: List[str]       # Source paths
    doc_path: Optional[Path]  # Documentation file
    language: str          # Primary language

@dataclass
class Config:
    features_root: str
    docs_root: str
    doc_pattern: str
    languages: List[str]
    auto_discover: bool
    exclude: List[str]
    features: Dict[str, List[str]]
```

## CLI Interface

```bash
# Initialize configuration
feat2.py init                              # Generate .feat.toml

# List features
feat2.py list                              # Show discovered features
feat2.py list --verbose                    # Include paths

# Inspect feature surface
feat2.py scan <feature>                    # Print to stdout
feat2.py scan <feature> --format json      # JSON output
feat2.py scan <feature> <subfeature>       # Filter by subfeature

# Update documentation
feat2.py update <feature>                  # Update one feature doc
feat2.py sync                              # Update all feature docs
feat2.py update <feature> --doc path.md    # Custom doc path

# Custom paths (bypass config)
feat2.py --paths src/custom.rs lib/other.py

# Configuration
feat2.py --config custom.toml scan global  # Use custom config
feat2.py --root /path/to/repo scan global  # Override repo root

# Validation
feat2.py check                             # Validate config
feat2.py check --missing-docs              # Report features without docs
```

## Implementation Patterns

### 1. Fail-Safe Discovery

- If config file missing → auto-discover with sensible defaults
- If auto-discovery fails → print diagnostic, suggest `init`
- If language unknown → warn and skip files
- If doc path not found → warn but continue (don't fail)

### 2. Incremental Adoption

- Works with zero configuration (use existing `feat.py` behavior as template)
- Gradual migration: `.feat.toml` can start minimal, grow as needed
- Backward compatible: can read old hardcoded `FEATURE_MAP` as fallback

### 3. Parser Extensibility

**Adding new language**:
1. Implement `Parser` subclass
2. Define regex patterns for public items
3. Register in `PARSERS` dict
4. Add to `languages` config

**Example stub (TypeScript)**:
```python
class TypeScriptParser(Parser):
    def parse_file(self, path: Path) -> List[Item]:
        # NOT IMPLEMENTED
        raise NotImplementedError("TypeScript parser not yet implemented")

    def supported_extensions(self) -> List[str]:
        return [".ts", ".tsx", ".js", ".jsx"]
```

### 4. Error Handling

- **Missing config**: Use defaults, log info message
- **Invalid config**: Fail fast with clear error
- **Missing feature**: Warn and skip
- **Parse error**: Log warning, continue (best-effort)
- **Missing doc file**: Warn, offer to create

## Feature Comparison

| Feature | feat.py | feat2.py |
|---------|---------|----------|
| Rust support | ✓ | ✓ |
| Python support | ✗ | ✓ (planned) |
| TypeScript support | ✗ | Stubbed |
| Auto-discovery | ✗ | ✓ |
| Config file | ✗ | ✓ (TOML) |
| Hardcoded paths | ✓ | ✗ |
| Multi-repo | ✗ | ✓ |
| `init` command | ✗ | ✓ |
| `sync` command | ✗ | ✓ |
| Flexible doc paths | ✗ | ✓ |
| Language plugins | ✗ | ✓ |

## Testing Strategy

### Unit Tests
- Config parsing and validation
- Parser regex patterns
- Feature discovery logic
- Doc path resolution

### Integration Tests
- Use `gitsim` to create virtual test repositories
- Test Rust project layout (Cargo-based)
- Test Python project layout (package-based)
- Test mixed-language repository
- Test edge cases (missing files, invalid config)

### Test Scenarios

**Scenario 1: Rust library (like RSB)**
```bash
gitsim template rust testlib
cd testlib
# Add .feat.toml and feature modules
feat2.py init
feat2.py list
feat2.py scan myfeature
```

**Scenario 2: Python package**
```bash
gitsim template python testpkg
cd testpkg
feat2.py init
feat2.py list
```

**Scenario 3: No config (pure auto-discover)**
```bash
gitsim template rust testlib
cd testlib
feat2.py list  # Should auto-discover features
```

## Migration Path

### Phase 1: Core Infrastructure (MVP)
- [x] Design and document strategy
- [ ] Config parsing (`.feat.toml`)
- [ ] Repository root detection
- [ ] Parser abstraction layer
- [ ] Rust parser (port from `feat.py`)

### Phase 2: Discovery & CLI
- [ ] Feature auto-discovery
- [ ] `init` command (generate config)
- [ ] `list` command (show features)
- [ ] `scan` command (inspect surface)

### Phase 3: Documentation Integration
- [ ] Doc path resolution
- [ ] `update` command (single feature)
- [ ] `sync` command (all features)
- [ ] Sentinel block management

### Phase 4: Multi-Language
- [ ] Python parser implementation
- [ ] Language detection logic
- [ ] TypeScript parser stub (NOT IMPLEMENTED message)

### Phase 5: Polish
- [ ] Error messages and diagnostics
- [ ] Validation (`check` command)
- [ ] Testing with `gitsim`
- [ ] Documentation (README, examples)

## Design Principles

1. **Zero-config by default**: Work out-of-box for standard layouts
2. **Fail gracefully**: Warn, don't crash; best-effort parsing
3. **Language-agnostic**: Clean abstraction for adding languages
4. **Convention-friendly**: Detect patterns (Cargo.toml, package.json)
5. **Flexible override**: Config can override any default
6. **Incremental adoption**: Start simple, grow config as needed
7. **Transparent behavior**: Log what's happening (discovery, paths)

## Open Questions

1. **Cargo.toml features**: Should we parse conditional compilation features or just directory structure?
   - Proposal: Directory structure primary, Cargo features as validation/hint

2. **Multi-language features**: How to handle features spanning Rust + Python?
   - Proposal: Support multiple parsers per feature, merge results

3. **Doc generation**: Should we generate skeleton docs for undocumented features?
   - Proposal: Yes, via `feat2.py init-docs <feature>`

4. **Version compatibility**: Should we maintain `feat.py` or fully migrate?
   - Proposal: Keep both temporarily, deprecation notice in `feat.py`

5. **Performance**: For large repos, should we cache parsed results?
   - Proposal: Future optimization, not MVP

## Related Files

- `bin/feat.py` - Original RSB-specific implementation
- `docs/tech/features/` - Feature documentation directory
- `.feat.toml` - Configuration file (to be created)

## References

- Rust RFC 2141: `pub use` re-exports
- Python PEP 8: Module exports and `__all__`
- TypeScript: Module resolution and exports
